// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"tg_bot/internal/database/model"
)

func newMailQueue(db *gorm.DB, opts ...gen.DOOption) mailQueue {
	_mailQueue := mailQueue{}

	_mailQueue.mailQueueDo.UseDB(db, opts...)
	_mailQueue.mailQueueDo.UseModel(&model.MailQueue{})

	tableName := _mailQueue.mailQueueDo.TableName()
	_mailQueue.ALL = field.NewAsterisk(tableName)
	_mailQueue.ID = field.NewInt64(tableName, "id")
	_mailQueue.InsertFingerprint = field.NewString(tableName, "insert_fingerprint")
	_mailQueue.ArticleID = field.NewInt64(tableName, "article_id")
	_mailQueue.Attempts = field.NewInt32(tableName, "attempts")
	_mailQueue.Sender = field.NewString(tableName, "sender")
	_mailQueue.Recipient = field.NewString(tableName, "recipient")
	_mailQueue.RawMessage = field.NewBytes(tableName, "raw_message")
	_mailQueue.DueTime = field.NewTime(tableName, "due_time")
	_mailQueue.LastSMTPCode = field.NewInt32(tableName, "last_smtp_code")
	_mailQueue.LastSMTPMessage = field.NewString(tableName, "last_smtp_message")
	_mailQueue.CreateTime = field.NewTime(tableName, "create_time")

	_mailQueue.fillFieldMap()

	return _mailQueue
}

type mailQueue struct {
	mailQueueDo

	ALL               field.Asterisk
	ID                field.Int64
	InsertFingerprint field.String
	ArticleID         field.Int64
	Attempts          field.Int32
	Sender            field.String
	Recipient         field.String
	RawMessage        field.Bytes
	DueTime           field.Time
	LastSMTPCode      field.Int32
	LastSMTPMessage   field.String
	CreateTime        field.Time

	fieldMap map[string]field.Expr
}

func (m mailQueue) Table(newTableName string) *mailQueue {
	m.mailQueueDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m mailQueue) As(alias string) *mailQueue {
	m.mailQueueDo.DO = *(m.mailQueueDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *mailQueue) updateTableName(table string) *mailQueue {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt64(table, "id")
	m.InsertFingerprint = field.NewString(table, "insert_fingerprint")
	m.ArticleID = field.NewInt64(table, "article_id")
	m.Attempts = field.NewInt32(table, "attempts")
	m.Sender = field.NewString(table, "sender")
	m.Recipient = field.NewString(table, "recipient")
	m.RawMessage = field.NewBytes(table, "raw_message")
	m.DueTime = field.NewTime(table, "due_time")
	m.LastSMTPCode = field.NewInt32(table, "last_smtp_code")
	m.LastSMTPMessage = field.NewString(table, "last_smtp_message")
	m.CreateTime = field.NewTime(table, "create_time")

	m.fillFieldMap()

	return m
}

func (m *mailQueue) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *mailQueue) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 11)
	m.fieldMap["id"] = m.ID
	m.fieldMap["insert_fingerprint"] = m.InsertFingerprint
	m.fieldMap["article_id"] = m.ArticleID
	m.fieldMap["attempts"] = m.Attempts
	m.fieldMap["sender"] = m.Sender
	m.fieldMap["recipient"] = m.Recipient
	m.fieldMap["raw_message"] = m.RawMessage
	m.fieldMap["due_time"] = m.DueTime
	m.fieldMap["last_smtp_code"] = m.LastSMTPCode
	m.fieldMap["last_smtp_message"] = m.LastSMTPMessage
	m.fieldMap["create_time"] = m.CreateTime
}

func (m mailQueue) clone(db *gorm.DB) mailQueue {
	m.mailQueueDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m mailQueue) replaceDB(db *gorm.DB) mailQueue {
	m.mailQueueDo.ReplaceDB(db)
	return m
}

type mailQueueDo struct{ gen.DO }

type IMailQueueDo interface {
	gen.SubQuery
	Debug() IMailQueueDo
	WithContext(ctx context.Context) IMailQueueDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMailQueueDo
	WriteDB() IMailQueueDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMailQueueDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMailQueueDo
	Not(conds ...gen.Condition) IMailQueueDo
	Or(conds ...gen.Condition) IMailQueueDo
	Select(conds ...field.Expr) IMailQueueDo
	Where(conds ...gen.Condition) IMailQueueDo
	Order(conds ...field.Expr) IMailQueueDo
	Distinct(cols ...field.Expr) IMailQueueDo
	Omit(cols ...field.Expr) IMailQueueDo
	Join(table schema.Tabler, on ...field.Expr) IMailQueueDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMailQueueDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMailQueueDo
	Group(cols ...field.Expr) IMailQueueDo
	Having(conds ...gen.Condition) IMailQueueDo
	Limit(limit int) IMailQueueDo
	Offset(offset int) IMailQueueDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMailQueueDo
	Unscoped() IMailQueueDo
	Create(values ...*model.MailQueue) error
	CreateInBatches(values []*model.MailQueue, batchSize int) error
	Save(values ...*model.MailQueue) error
	First() (*model.MailQueue, error)
	Take() (*model.MailQueue, error)
	Last() (*model.MailQueue, error)
	Find() ([]*model.MailQueue, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MailQueue, err error)
	FindInBatches(result *[]*model.MailQueue, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MailQueue) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMailQueueDo
	Assign(attrs ...field.AssignExpr) IMailQueueDo
	Joins(fields ...field.RelationField) IMailQueueDo
	Preload(fields ...field.RelationField) IMailQueueDo
	FirstOrInit() (*model.MailQueue, error)
	FirstOrCreate() (*model.MailQueue, error)
	FindByPage(offset int, limit int) (result []*model.MailQueue, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMailQueueDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m mailQueueDo) Debug() IMailQueueDo {
	return m.withDO(m.DO.Debug())
}

func (m mailQueueDo) WithContext(ctx context.Context) IMailQueueDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m mailQueueDo) ReadDB() IMailQueueDo {
	return m.Clauses(dbresolver.Read)
}

func (m mailQueueDo) WriteDB() IMailQueueDo {
	return m.Clauses(dbresolver.Write)
}

func (m mailQueueDo) Session(config *gorm.Session) IMailQueueDo {
	return m.withDO(m.DO.Session(config))
}

func (m mailQueueDo) Clauses(conds ...clause.Expression) IMailQueueDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m mailQueueDo) Returning(value interface{}, columns ...string) IMailQueueDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m mailQueueDo) Not(conds ...gen.Condition) IMailQueueDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m mailQueueDo) Or(conds ...gen.Condition) IMailQueueDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m mailQueueDo) Select(conds ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m mailQueueDo) Where(conds ...gen.Condition) IMailQueueDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m mailQueueDo) Order(conds ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m mailQueueDo) Distinct(cols ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m mailQueueDo) Omit(cols ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m mailQueueDo) Join(table schema.Tabler, on ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m mailQueueDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m mailQueueDo) RightJoin(table schema.Tabler, on ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m mailQueueDo) Group(cols ...field.Expr) IMailQueueDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m mailQueueDo) Having(conds ...gen.Condition) IMailQueueDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m mailQueueDo) Limit(limit int) IMailQueueDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m mailQueueDo) Offset(offset int) IMailQueueDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m mailQueueDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMailQueueDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m mailQueueDo) Unscoped() IMailQueueDo {
	return m.withDO(m.DO.Unscoped())
}

func (m mailQueueDo) Create(values ...*model.MailQueue) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m mailQueueDo) CreateInBatches(values []*model.MailQueue, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m mailQueueDo) Save(values ...*model.MailQueue) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m mailQueueDo) First() (*model.MailQueue, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailQueue), nil
	}
}

func (m mailQueueDo) Take() (*model.MailQueue, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailQueue), nil
	}
}

func (m mailQueueDo) Last() (*model.MailQueue, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailQueue), nil
	}
}

func (m mailQueueDo) Find() ([]*model.MailQueue, error) {
	result, err := m.DO.Find()
	return result.([]*model.MailQueue), err
}

func (m mailQueueDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MailQueue, err error) {
	buf := make([]*model.MailQueue, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m mailQueueDo) FindInBatches(result *[]*model.MailQueue, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m mailQueueDo) Attrs(attrs ...field.AssignExpr) IMailQueueDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m mailQueueDo) Assign(attrs ...field.AssignExpr) IMailQueueDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m mailQueueDo) Joins(fields ...field.RelationField) IMailQueueDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m mailQueueDo) Preload(fields ...field.RelationField) IMailQueueDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m mailQueueDo) FirstOrInit() (*model.MailQueue, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailQueue), nil
	}
}

func (m mailQueueDo) FirstOrCreate() (*model.MailQueue, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailQueue), nil
	}
}

func (m mailQueueDo) FindByPage(offset int, limit int) (result []*model.MailQueue, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m mailQueueDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m mailQueueDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m mailQueueDo) Delete(models ...*model.MailQueue) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *mailQueueDo) withDO(do gen.Dao) *mailQueueDo {
	m.DO = *do.(*gen.DO)
	return m
}
