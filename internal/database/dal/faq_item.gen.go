// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"tg_bot/internal/database/model"
)

func newFaqItem(db *gorm.DB, opts ...gen.DOOption) faqItem {
	_faqItem := faqItem{}

	_faqItem.faqItemDo.UseDB(db, opts...)
	_faqItem.faqItemDo.UseModel(&model.FaqItem{})

	tableName := _faqItem.faqItemDo.TableName()
	_faqItem.ALL = field.NewAsterisk(tableName)
	_faqItem.ID = field.NewInt32(tableName, "id")
	_faqItem.FNumber = field.NewString(tableName, "f_number")
	_faqItem.FSubject = field.NewString(tableName, "f_subject")
	_faqItem.FName = field.NewString(tableName, "f_name")
	_faqItem.FLanguageID = field.NewInt32(tableName, "f_language_id")
	_faqItem.StateID = field.NewInt32(tableName, "state_id")
	_faqItem.CategoryID = field.NewInt32(tableName, "category_id")
	_faqItem.Approved = field.NewInt32(tableName, "approved")
	_faqItem.ValidID = field.NewInt32(tableName, "valid_id")
	_faqItem.ContentType = field.NewString(tableName, "content_type")
	_faqItem.FKeywords = field.NewString(tableName, "f_keywords")
	_faqItem.FField1 = field.NewString(tableName, "f_field1")
	_faqItem.FField2 = field.NewString(tableName, "f_field2")
	_faqItem.FField3 = field.NewString(tableName, "f_field3")
	_faqItem.FField4 = field.NewString(tableName, "f_field4")
	_faqItem.FField5 = field.NewString(tableName, "f_field5")
	_faqItem.FField6 = field.NewString(tableName, "f_field6")
	_faqItem.Created = field.NewTime(tableName, "created")
	_faqItem.CreatedBy = field.NewInt32(tableName, "created_by")
	_faqItem.Changed = field.NewTime(tableName, "changed")
	_faqItem.ChangedBy = field.NewInt32(tableName, "changed_by")

	_faqItem.fillFieldMap()

	return _faqItem
}

type faqItem struct {
	faqItemDo

	ALL         field.Asterisk
	ID          field.Int32
	FNumber     field.String
	FSubject    field.String
	FName       field.String
	FLanguageID field.Int32
	StateID     field.Int32
	CategoryID  field.Int32
	Approved    field.Int32
	ValidID     field.Int32
	ContentType field.String
	FKeywords   field.String
	FField1     field.String
	FField2     field.String
	FField3     field.String
	FField4     field.String
	FField5     field.String
	FField6     field.String
	Created     field.Time
	CreatedBy   field.Int32
	Changed     field.Time
	ChangedBy   field.Int32

	fieldMap map[string]field.Expr
}

func (f faqItem) Table(newTableName string) *faqItem {
	f.faqItemDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f faqItem) As(alias string) *faqItem {
	f.faqItemDo.DO = *(f.faqItemDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *faqItem) updateTableName(table string) *faqItem {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewInt32(table, "id")
	f.FNumber = field.NewString(table, "f_number")
	f.FSubject = field.NewString(table, "f_subject")
	f.FName = field.NewString(table, "f_name")
	f.FLanguageID = field.NewInt32(table, "f_language_id")
	f.StateID = field.NewInt32(table, "state_id")
	f.CategoryID = field.NewInt32(table, "category_id")
	f.Approved = field.NewInt32(table, "approved")
	f.ValidID = field.NewInt32(table, "valid_id")
	f.ContentType = field.NewString(table, "content_type")
	f.FKeywords = field.NewString(table, "f_keywords")
	f.FField1 = field.NewString(table, "f_field1")
	f.FField2 = field.NewString(table, "f_field2")
	f.FField3 = field.NewString(table, "f_field3")
	f.FField4 = field.NewString(table, "f_field4")
	f.FField5 = field.NewString(table, "f_field5")
	f.FField6 = field.NewString(table, "f_field6")
	f.Created = field.NewTime(table, "created")
	f.CreatedBy = field.NewInt32(table, "created_by")
	f.Changed = field.NewTime(table, "changed")
	f.ChangedBy = field.NewInt32(table, "changed_by")

	f.fillFieldMap()

	return f
}

func (f *faqItem) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *faqItem) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 21)
	f.fieldMap["id"] = f.ID
	f.fieldMap["f_number"] = f.FNumber
	f.fieldMap["f_subject"] = f.FSubject
	f.fieldMap["f_name"] = f.FName
	f.fieldMap["f_language_id"] = f.FLanguageID
	f.fieldMap["state_id"] = f.StateID
	f.fieldMap["category_id"] = f.CategoryID
	f.fieldMap["approved"] = f.Approved
	f.fieldMap["valid_id"] = f.ValidID
	f.fieldMap["content_type"] = f.ContentType
	f.fieldMap["f_keywords"] = f.FKeywords
	f.fieldMap["f_field1"] = f.FField1
	f.fieldMap["f_field2"] = f.FField2
	f.fieldMap["f_field3"] = f.FField3
	f.fieldMap["f_field4"] = f.FField4
	f.fieldMap["f_field5"] = f.FField5
	f.fieldMap["f_field6"] = f.FField6
	f.fieldMap["created"] = f.Created
	f.fieldMap["created_by"] = f.CreatedBy
	f.fieldMap["changed"] = f.Changed
	f.fieldMap["changed_by"] = f.ChangedBy
}

func (f faqItem) clone(db *gorm.DB) faqItem {
	f.faqItemDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f faqItem) replaceDB(db *gorm.DB) faqItem {
	f.faqItemDo.ReplaceDB(db)
	return f
}

type faqItemDo struct{ gen.DO }

type IFaqItemDo interface {
	gen.SubQuery
	Debug() IFaqItemDo
	WithContext(ctx context.Context) IFaqItemDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFaqItemDo
	WriteDB() IFaqItemDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFaqItemDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFaqItemDo
	Not(conds ...gen.Condition) IFaqItemDo
	Or(conds ...gen.Condition) IFaqItemDo
	Select(conds ...field.Expr) IFaqItemDo
	Where(conds ...gen.Condition) IFaqItemDo
	Order(conds ...field.Expr) IFaqItemDo
	Distinct(cols ...field.Expr) IFaqItemDo
	Omit(cols ...field.Expr) IFaqItemDo
	Join(table schema.Tabler, on ...field.Expr) IFaqItemDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFaqItemDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFaqItemDo
	Group(cols ...field.Expr) IFaqItemDo
	Having(conds ...gen.Condition) IFaqItemDo
	Limit(limit int) IFaqItemDo
	Offset(offset int) IFaqItemDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFaqItemDo
	Unscoped() IFaqItemDo
	Create(values ...*model.FaqItem) error
	CreateInBatches(values []*model.FaqItem, batchSize int) error
	Save(values ...*model.FaqItem) error
	First() (*model.FaqItem, error)
	Take() (*model.FaqItem, error)
	Last() (*model.FaqItem, error)
	Find() ([]*model.FaqItem, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FaqItem, err error)
	FindInBatches(result *[]*model.FaqItem, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FaqItem) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFaqItemDo
	Assign(attrs ...field.AssignExpr) IFaqItemDo
	Joins(fields ...field.RelationField) IFaqItemDo
	Preload(fields ...field.RelationField) IFaqItemDo
	FirstOrInit() (*model.FaqItem, error)
	FirstOrCreate() (*model.FaqItem, error)
	FindByPage(offset int, limit int) (result []*model.FaqItem, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFaqItemDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f faqItemDo) Debug() IFaqItemDo {
	return f.withDO(f.DO.Debug())
}

func (f faqItemDo) WithContext(ctx context.Context) IFaqItemDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f faqItemDo) ReadDB() IFaqItemDo {
	return f.Clauses(dbresolver.Read)
}

func (f faqItemDo) WriteDB() IFaqItemDo {
	return f.Clauses(dbresolver.Write)
}

func (f faqItemDo) Session(config *gorm.Session) IFaqItemDo {
	return f.withDO(f.DO.Session(config))
}

func (f faqItemDo) Clauses(conds ...clause.Expression) IFaqItemDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f faqItemDo) Returning(value interface{}, columns ...string) IFaqItemDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f faqItemDo) Not(conds ...gen.Condition) IFaqItemDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f faqItemDo) Or(conds ...gen.Condition) IFaqItemDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f faqItemDo) Select(conds ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f faqItemDo) Where(conds ...gen.Condition) IFaqItemDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f faqItemDo) Order(conds ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f faqItemDo) Distinct(cols ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f faqItemDo) Omit(cols ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f faqItemDo) Join(table schema.Tabler, on ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f faqItemDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f faqItemDo) RightJoin(table schema.Tabler, on ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f faqItemDo) Group(cols ...field.Expr) IFaqItemDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f faqItemDo) Having(conds ...gen.Condition) IFaqItemDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f faqItemDo) Limit(limit int) IFaqItemDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f faqItemDo) Offset(offset int) IFaqItemDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f faqItemDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFaqItemDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f faqItemDo) Unscoped() IFaqItemDo {
	return f.withDO(f.DO.Unscoped())
}

func (f faqItemDo) Create(values ...*model.FaqItem) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f faqItemDo) CreateInBatches(values []*model.FaqItem, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f faqItemDo) Save(values ...*model.FaqItem) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f faqItemDo) First() (*model.FaqItem, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqItem), nil
	}
}

func (f faqItemDo) Take() (*model.FaqItem, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqItem), nil
	}
}

func (f faqItemDo) Last() (*model.FaqItem, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqItem), nil
	}
}

func (f faqItemDo) Find() ([]*model.FaqItem, error) {
	result, err := f.DO.Find()
	return result.([]*model.FaqItem), err
}

func (f faqItemDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FaqItem, err error) {
	buf := make([]*model.FaqItem, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f faqItemDo) FindInBatches(result *[]*model.FaqItem, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f faqItemDo) Attrs(attrs ...field.AssignExpr) IFaqItemDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f faqItemDo) Assign(attrs ...field.AssignExpr) IFaqItemDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f faqItemDo) Joins(fields ...field.RelationField) IFaqItemDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f faqItemDo) Preload(fields ...field.RelationField) IFaqItemDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f faqItemDo) FirstOrInit() (*model.FaqItem, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqItem), nil
	}
}

func (f faqItemDo) FirstOrCreate() (*model.FaqItem, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqItem), nil
	}
}

func (f faqItemDo) FindByPage(offset int, limit int) (result []*model.FaqItem, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f faqItemDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f faqItemDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f faqItemDo) Delete(models ...*model.FaqItem) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *faqItemDo) withDO(do gen.Dao) *faqItemDo {
	f.DO = *do.(*gen.DO)
	return f
}
