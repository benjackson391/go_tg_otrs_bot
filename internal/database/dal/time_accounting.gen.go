// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"tg_bot/internal/database/model"
)

func newTimeAccounting(db *gorm.DB, opts ...gen.DOOption) timeAccounting {
	_timeAccounting := timeAccounting{}

	_timeAccounting.timeAccountingDo.UseDB(db, opts...)
	_timeAccounting.timeAccountingDo.UseModel(&model.TimeAccounting{})

	tableName := _timeAccounting.timeAccountingDo.TableName()
	_timeAccounting.ALL = field.NewAsterisk(tableName)
	_timeAccounting.ID = field.NewInt64(tableName, "id")
	_timeAccounting.TicketID = field.NewInt64(tableName, "ticket_id")
	_timeAccounting.ArticleID = field.NewInt64(tableName, "article_id")
	_timeAccounting.TimeUnit = field.NewFloat64(tableName, "time_unit")
	_timeAccounting.CreateTime = field.NewTime(tableName, "create_time")
	_timeAccounting.CreateBy = field.NewInt32(tableName, "create_by")
	_timeAccounting.ChangeTime = field.NewTime(tableName, "change_time")
	_timeAccounting.ChangeBy = field.NewInt32(tableName, "change_by")

	_timeAccounting.fillFieldMap()

	return _timeAccounting
}

type timeAccounting struct {
	timeAccountingDo

	ALL        field.Asterisk
	ID         field.Int64
	TicketID   field.Int64
	ArticleID  field.Int64
	TimeUnit   field.Float64
	CreateTime field.Time
	CreateBy   field.Int32
	ChangeTime field.Time
	ChangeBy   field.Int32

	fieldMap map[string]field.Expr
}

func (t timeAccounting) Table(newTableName string) *timeAccounting {
	t.timeAccountingDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t timeAccounting) As(alias string) *timeAccounting {
	t.timeAccountingDo.DO = *(t.timeAccountingDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *timeAccounting) updateTableName(table string) *timeAccounting {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.TicketID = field.NewInt64(table, "ticket_id")
	t.ArticleID = field.NewInt64(table, "article_id")
	t.TimeUnit = field.NewFloat64(table, "time_unit")
	t.CreateTime = field.NewTime(table, "create_time")
	t.CreateBy = field.NewInt32(table, "create_by")
	t.ChangeTime = field.NewTime(table, "change_time")
	t.ChangeBy = field.NewInt32(table, "change_by")

	t.fillFieldMap()

	return t
}

func (t *timeAccounting) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *timeAccounting) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 8)
	t.fieldMap["id"] = t.ID
	t.fieldMap["ticket_id"] = t.TicketID
	t.fieldMap["article_id"] = t.ArticleID
	t.fieldMap["time_unit"] = t.TimeUnit
	t.fieldMap["create_time"] = t.CreateTime
	t.fieldMap["create_by"] = t.CreateBy
	t.fieldMap["change_time"] = t.ChangeTime
	t.fieldMap["change_by"] = t.ChangeBy
}

func (t timeAccounting) clone(db *gorm.DB) timeAccounting {
	t.timeAccountingDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t timeAccounting) replaceDB(db *gorm.DB) timeAccounting {
	t.timeAccountingDo.ReplaceDB(db)
	return t
}

type timeAccountingDo struct{ gen.DO }

type ITimeAccountingDo interface {
	gen.SubQuery
	Debug() ITimeAccountingDo
	WithContext(ctx context.Context) ITimeAccountingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITimeAccountingDo
	WriteDB() ITimeAccountingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITimeAccountingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITimeAccountingDo
	Not(conds ...gen.Condition) ITimeAccountingDo
	Or(conds ...gen.Condition) ITimeAccountingDo
	Select(conds ...field.Expr) ITimeAccountingDo
	Where(conds ...gen.Condition) ITimeAccountingDo
	Order(conds ...field.Expr) ITimeAccountingDo
	Distinct(cols ...field.Expr) ITimeAccountingDo
	Omit(cols ...field.Expr) ITimeAccountingDo
	Join(table schema.Tabler, on ...field.Expr) ITimeAccountingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITimeAccountingDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITimeAccountingDo
	Group(cols ...field.Expr) ITimeAccountingDo
	Having(conds ...gen.Condition) ITimeAccountingDo
	Limit(limit int) ITimeAccountingDo
	Offset(offset int) ITimeAccountingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITimeAccountingDo
	Unscoped() ITimeAccountingDo
	Create(values ...*model.TimeAccounting) error
	CreateInBatches(values []*model.TimeAccounting, batchSize int) error
	Save(values ...*model.TimeAccounting) error
	First() (*model.TimeAccounting, error)
	Take() (*model.TimeAccounting, error)
	Last() (*model.TimeAccounting, error)
	Find() ([]*model.TimeAccounting, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TimeAccounting, err error)
	FindInBatches(result *[]*model.TimeAccounting, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TimeAccounting) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITimeAccountingDo
	Assign(attrs ...field.AssignExpr) ITimeAccountingDo
	Joins(fields ...field.RelationField) ITimeAccountingDo
	Preload(fields ...field.RelationField) ITimeAccountingDo
	FirstOrInit() (*model.TimeAccounting, error)
	FirstOrCreate() (*model.TimeAccounting, error)
	FindByPage(offset int, limit int) (result []*model.TimeAccounting, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITimeAccountingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t timeAccountingDo) Debug() ITimeAccountingDo {
	return t.withDO(t.DO.Debug())
}

func (t timeAccountingDo) WithContext(ctx context.Context) ITimeAccountingDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t timeAccountingDo) ReadDB() ITimeAccountingDo {
	return t.Clauses(dbresolver.Read)
}

func (t timeAccountingDo) WriteDB() ITimeAccountingDo {
	return t.Clauses(dbresolver.Write)
}

func (t timeAccountingDo) Session(config *gorm.Session) ITimeAccountingDo {
	return t.withDO(t.DO.Session(config))
}

func (t timeAccountingDo) Clauses(conds ...clause.Expression) ITimeAccountingDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t timeAccountingDo) Returning(value interface{}, columns ...string) ITimeAccountingDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t timeAccountingDo) Not(conds ...gen.Condition) ITimeAccountingDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t timeAccountingDo) Or(conds ...gen.Condition) ITimeAccountingDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t timeAccountingDo) Select(conds ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t timeAccountingDo) Where(conds ...gen.Condition) ITimeAccountingDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t timeAccountingDo) Order(conds ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t timeAccountingDo) Distinct(cols ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t timeAccountingDo) Omit(cols ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t timeAccountingDo) Join(table schema.Tabler, on ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t timeAccountingDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t timeAccountingDo) RightJoin(table schema.Tabler, on ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t timeAccountingDo) Group(cols ...field.Expr) ITimeAccountingDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t timeAccountingDo) Having(conds ...gen.Condition) ITimeAccountingDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t timeAccountingDo) Limit(limit int) ITimeAccountingDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t timeAccountingDo) Offset(offset int) ITimeAccountingDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t timeAccountingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITimeAccountingDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t timeAccountingDo) Unscoped() ITimeAccountingDo {
	return t.withDO(t.DO.Unscoped())
}

func (t timeAccountingDo) Create(values ...*model.TimeAccounting) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t timeAccountingDo) CreateInBatches(values []*model.TimeAccounting, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t timeAccountingDo) Save(values ...*model.TimeAccounting) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t timeAccountingDo) First() (*model.TimeAccounting, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TimeAccounting), nil
	}
}

func (t timeAccountingDo) Take() (*model.TimeAccounting, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TimeAccounting), nil
	}
}

func (t timeAccountingDo) Last() (*model.TimeAccounting, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TimeAccounting), nil
	}
}

func (t timeAccountingDo) Find() ([]*model.TimeAccounting, error) {
	result, err := t.DO.Find()
	return result.([]*model.TimeAccounting), err
}

func (t timeAccountingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TimeAccounting, err error) {
	buf := make([]*model.TimeAccounting, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t timeAccountingDo) FindInBatches(result *[]*model.TimeAccounting, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t timeAccountingDo) Attrs(attrs ...field.AssignExpr) ITimeAccountingDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t timeAccountingDo) Assign(attrs ...field.AssignExpr) ITimeAccountingDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t timeAccountingDo) Joins(fields ...field.RelationField) ITimeAccountingDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t timeAccountingDo) Preload(fields ...field.RelationField) ITimeAccountingDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t timeAccountingDo) FirstOrInit() (*model.TimeAccounting, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TimeAccounting), nil
	}
}

func (t timeAccountingDo) FirstOrCreate() (*model.TimeAccounting, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TimeAccounting), nil
	}
}

func (t timeAccountingDo) FindByPage(offset int, limit int) (result []*model.TimeAccounting, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t timeAccountingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t timeAccountingDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t timeAccountingDo) Delete(models ...*model.TimeAccounting) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *timeAccountingDo) withDO(do gen.Dao) *timeAccountingDo {
	t.DO = *do.(*gen.DO)
	return t
}
