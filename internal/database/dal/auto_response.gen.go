// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"tg_bot/internal/database/model"
)

func newAutoResponse(db *gorm.DB, opts ...gen.DOOption) autoResponse {
	_autoResponse := autoResponse{}

	_autoResponse.autoResponseDo.UseDB(db, opts...)
	_autoResponse.autoResponseDo.UseModel(&model.AutoResponse{})

	tableName := _autoResponse.autoResponseDo.TableName()
	_autoResponse.ALL = field.NewAsterisk(tableName)
	_autoResponse.ID = field.NewInt32(tableName, "id")
	_autoResponse.Name = field.NewString(tableName, "name")
	_autoResponse.Text0 = field.NewString(tableName, "text0")
	_autoResponse.Text1 = field.NewString(tableName, "text1")
	_autoResponse.TypeID = field.NewInt32(tableName, "type_id")
	_autoResponse.SystemAddressID = field.NewInt32(tableName, "system_address_id")
	_autoResponse.ContentType = field.NewString(tableName, "content_type")
	_autoResponse.Comments = field.NewString(tableName, "comments")
	_autoResponse.ValidID = field.NewInt32(tableName, "valid_id")
	_autoResponse.CreateTime = field.NewTime(tableName, "create_time")
	_autoResponse.CreateBy = field.NewInt32(tableName, "create_by")
	_autoResponse.ChangeTime = field.NewTime(tableName, "change_time")
	_autoResponse.ChangeBy = field.NewInt32(tableName, "change_by")

	_autoResponse.fillFieldMap()

	return _autoResponse
}

type autoResponse struct {
	autoResponseDo

	ALL             field.Asterisk
	ID              field.Int32
	Name            field.String
	Text0           field.String
	Text1           field.String
	TypeID          field.Int32
	SystemAddressID field.Int32
	ContentType     field.String
	Comments        field.String
	ValidID         field.Int32
	CreateTime      field.Time
	CreateBy        field.Int32
	ChangeTime      field.Time
	ChangeBy        field.Int32

	fieldMap map[string]field.Expr
}

func (a autoResponse) Table(newTableName string) *autoResponse {
	a.autoResponseDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a autoResponse) As(alias string) *autoResponse {
	a.autoResponseDo.DO = *(a.autoResponseDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *autoResponse) updateTableName(table string) *autoResponse {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt32(table, "id")
	a.Name = field.NewString(table, "name")
	a.Text0 = field.NewString(table, "text0")
	a.Text1 = field.NewString(table, "text1")
	a.TypeID = field.NewInt32(table, "type_id")
	a.SystemAddressID = field.NewInt32(table, "system_address_id")
	a.ContentType = field.NewString(table, "content_type")
	a.Comments = field.NewString(table, "comments")
	a.ValidID = field.NewInt32(table, "valid_id")
	a.CreateTime = field.NewTime(table, "create_time")
	a.CreateBy = field.NewInt32(table, "create_by")
	a.ChangeTime = field.NewTime(table, "change_time")
	a.ChangeBy = field.NewInt32(table, "change_by")

	a.fillFieldMap()

	return a
}

func (a *autoResponse) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *autoResponse) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 13)
	a.fieldMap["id"] = a.ID
	a.fieldMap["name"] = a.Name
	a.fieldMap["text0"] = a.Text0
	a.fieldMap["text1"] = a.Text1
	a.fieldMap["type_id"] = a.TypeID
	a.fieldMap["system_address_id"] = a.SystemAddressID
	a.fieldMap["content_type"] = a.ContentType
	a.fieldMap["comments"] = a.Comments
	a.fieldMap["valid_id"] = a.ValidID
	a.fieldMap["create_time"] = a.CreateTime
	a.fieldMap["create_by"] = a.CreateBy
	a.fieldMap["change_time"] = a.ChangeTime
	a.fieldMap["change_by"] = a.ChangeBy
}

func (a autoResponse) clone(db *gorm.DB) autoResponse {
	a.autoResponseDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a autoResponse) replaceDB(db *gorm.DB) autoResponse {
	a.autoResponseDo.ReplaceDB(db)
	return a
}

type autoResponseDo struct{ gen.DO }

type IAutoResponseDo interface {
	gen.SubQuery
	Debug() IAutoResponseDo
	WithContext(ctx context.Context) IAutoResponseDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAutoResponseDo
	WriteDB() IAutoResponseDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAutoResponseDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAutoResponseDo
	Not(conds ...gen.Condition) IAutoResponseDo
	Or(conds ...gen.Condition) IAutoResponseDo
	Select(conds ...field.Expr) IAutoResponseDo
	Where(conds ...gen.Condition) IAutoResponseDo
	Order(conds ...field.Expr) IAutoResponseDo
	Distinct(cols ...field.Expr) IAutoResponseDo
	Omit(cols ...field.Expr) IAutoResponseDo
	Join(table schema.Tabler, on ...field.Expr) IAutoResponseDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAutoResponseDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAutoResponseDo
	Group(cols ...field.Expr) IAutoResponseDo
	Having(conds ...gen.Condition) IAutoResponseDo
	Limit(limit int) IAutoResponseDo
	Offset(offset int) IAutoResponseDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAutoResponseDo
	Unscoped() IAutoResponseDo
	Create(values ...*model.AutoResponse) error
	CreateInBatches(values []*model.AutoResponse, batchSize int) error
	Save(values ...*model.AutoResponse) error
	First() (*model.AutoResponse, error)
	Take() (*model.AutoResponse, error)
	Last() (*model.AutoResponse, error)
	Find() ([]*model.AutoResponse, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AutoResponse, err error)
	FindInBatches(result *[]*model.AutoResponse, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AutoResponse) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAutoResponseDo
	Assign(attrs ...field.AssignExpr) IAutoResponseDo
	Joins(fields ...field.RelationField) IAutoResponseDo
	Preload(fields ...field.RelationField) IAutoResponseDo
	FirstOrInit() (*model.AutoResponse, error)
	FirstOrCreate() (*model.AutoResponse, error)
	FindByPage(offset int, limit int) (result []*model.AutoResponse, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAutoResponseDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a autoResponseDo) Debug() IAutoResponseDo {
	return a.withDO(a.DO.Debug())
}

func (a autoResponseDo) WithContext(ctx context.Context) IAutoResponseDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a autoResponseDo) ReadDB() IAutoResponseDo {
	return a.Clauses(dbresolver.Read)
}

func (a autoResponseDo) WriteDB() IAutoResponseDo {
	return a.Clauses(dbresolver.Write)
}

func (a autoResponseDo) Session(config *gorm.Session) IAutoResponseDo {
	return a.withDO(a.DO.Session(config))
}

func (a autoResponseDo) Clauses(conds ...clause.Expression) IAutoResponseDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a autoResponseDo) Returning(value interface{}, columns ...string) IAutoResponseDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a autoResponseDo) Not(conds ...gen.Condition) IAutoResponseDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a autoResponseDo) Or(conds ...gen.Condition) IAutoResponseDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a autoResponseDo) Select(conds ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a autoResponseDo) Where(conds ...gen.Condition) IAutoResponseDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a autoResponseDo) Order(conds ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a autoResponseDo) Distinct(cols ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a autoResponseDo) Omit(cols ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a autoResponseDo) Join(table schema.Tabler, on ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a autoResponseDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a autoResponseDo) RightJoin(table schema.Tabler, on ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a autoResponseDo) Group(cols ...field.Expr) IAutoResponseDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a autoResponseDo) Having(conds ...gen.Condition) IAutoResponseDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a autoResponseDo) Limit(limit int) IAutoResponseDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a autoResponseDo) Offset(offset int) IAutoResponseDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a autoResponseDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAutoResponseDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a autoResponseDo) Unscoped() IAutoResponseDo {
	return a.withDO(a.DO.Unscoped())
}

func (a autoResponseDo) Create(values ...*model.AutoResponse) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a autoResponseDo) CreateInBatches(values []*model.AutoResponse, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a autoResponseDo) Save(values ...*model.AutoResponse) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a autoResponseDo) First() (*model.AutoResponse, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoResponse), nil
	}
}

func (a autoResponseDo) Take() (*model.AutoResponse, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoResponse), nil
	}
}

func (a autoResponseDo) Last() (*model.AutoResponse, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoResponse), nil
	}
}

func (a autoResponseDo) Find() ([]*model.AutoResponse, error) {
	result, err := a.DO.Find()
	return result.([]*model.AutoResponse), err
}

func (a autoResponseDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AutoResponse, err error) {
	buf := make([]*model.AutoResponse, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a autoResponseDo) FindInBatches(result *[]*model.AutoResponse, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a autoResponseDo) Attrs(attrs ...field.AssignExpr) IAutoResponseDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a autoResponseDo) Assign(attrs ...field.AssignExpr) IAutoResponseDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a autoResponseDo) Joins(fields ...field.RelationField) IAutoResponseDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a autoResponseDo) Preload(fields ...field.RelationField) IAutoResponseDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a autoResponseDo) FirstOrInit() (*model.AutoResponse, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoResponse), nil
	}
}

func (a autoResponseDo) FirstOrCreate() (*model.AutoResponse, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoResponse), nil
	}
}

func (a autoResponseDo) FindByPage(offset int, limit int) (result []*model.AutoResponse, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a autoResponseDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a autoResponseDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a autoResponseDo) Delete(models ...*model.AutoResponse) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *autoResponseDo) withDO(do gen.Dao) *autoResponseDo {
	a.DO = *do.(*gen.DO)
	return a
}
