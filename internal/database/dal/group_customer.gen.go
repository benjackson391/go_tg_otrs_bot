// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"tg_bot/internal/database/model"
)

func newGroupCustomer(db *gorm.DB, opts ...gen.DOOption) groupCustomer {
	_groupCustomer := groupCustomer{}

	_groupCustomer.groupCustomerDo.UseDB(db, opts...)
	_groupCustomer.groupCustomerDo.UseModel(&model.GroupCustomer{})

	tableName := _groupCustomer.groupCustomerDo.TableName()
	_groupCustomer.ALL = field.NewAsterisk(tableName)
	_groupCustomer.CustomerID = field.NewString(tableName, "customer_id")
	_groupCustomer.GroupID = field.NewInt32(tableName, "group_id")
	_groupCustomer.PermissionKey = field.NewString(tableName, "permission_key")
	_groupCustomer.PermissionValue = field.NewInt32(tableName, "permission_value")
	_groupCustomer.PermissionContext = field.NewString(tableName, "permission_context")
	_groupCustomer.CreateTime = field.NewTime(tableName, "create_time")
	_groupCustomer.CreateBy = field.NewInt32(tableName, "create_by")
	_groupCustomer.ChangeTime = field.NewTime(tableName, "change_time")
	_groupCustomer.ChangeBy = field.NewInt32(tableName, "change_by")

	_groupCustomer.fillFieldMap()

	return _groupCustomer
}

type groupCustomer struct {
	groupCustomerDo

	ALL               field.Asterisk
	CustomerID        field.String
	GroupID           field.Int32
	PermissionKey     field.String
	PermissionValue   field.Int32
	PermissionContext field.String
	CreateTime        field.Time
	CreateBy          field.Int32
	ChangeTime        field.Time
	ChangeBy          field.Int32

	fieldMap map[string]field.Expr
}

func (g groupCustomer) Table(newTableName string) *groupCustomer {
	g.groupCustomerDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g groupCustomer) As(alias string) *groupCustomer {
	g.groupCustomerDo.DO = *(g.groupCustomerDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *groupCustomer) updateTableName(table string) *groupCustomer {
	g.ALL = field.NewAsterisk(table)
	g.CustomerID = field.NewString(table, "customer_id")
	g.GroupID = field.NewInt32(table, "group_id")
	g.PermissionKey = field.NewString(table, "permission_key")
	g.PermissionValue = field.NewInt32(table, "permission_value")
	g.PermissionContext = field.NewString(table, "permission_context")
	g.CreateTime = field.NewTime(table, "create_time")
	g.CreateBy = field.NewInt32(table, "create_by")
	g.ChangeTime = field.NewTime(table, "change_time")
	g.ChangeBy = field.NewInt32(table, "change_by")

	g.fillFieldMap()

	return g
}

func (g *groupCustomer) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *groupCustomer) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 9)
	g.fieldMap["customer_id"] = g.CustomerID
	g.fieldMap["group_id"] = g.GroupID
	g.fieldMap["permission_key"] = g.PermissionKey
	g.fieldMap["permission_value"] = g.PermissionValue
	g.fieldMap["permission_context"] = g.PermissionContext
	g.fieldMap["create_time"] = g.CreateTime
	g.fieldMap["create_by"] = g.CreateBy
	g.fieldMap["change_time"] = g.ChangeTime
	g.fieldMap["change_by"] = g.ChangeBy
}

func (g groupCustomer) clone(db *gorm.DB) groupCustomer {
	g.groupCustomerDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g groupCustomer) replaceDB(db *gorm.DB) groupCustomer {
	g.groupCustomerDo.ReplaceDB(db)
	return g
}

type groupCustomerDo struct{ gen.DO }

type IGroupCustomerDo interface {
	gen.SubQuery
	Debug() IGroupCustomerDo
	WithContext(ctx context.Context) IGroupCustomerDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGroupCustomerDo
	WriteDB() IGroupCustomerDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGroupCustomerDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGroupCustomerDo
	Not(conds ...gen.Condition) IGroupCustomerDo
	Or(conds ...gen.Condition) IGroupCustomerDo
	Select(conds ...field.Expr) IGroupCustomerDo
	Where(conds ...gen.Condition) IGroupCustomerDo
	Order(conds ...field.Expr) IGroupCustomerDo
	Distinct(cols ...field.Expr) IGroupCustomerDo
	Omit(cols ...field.Expr) IGroupCustomerDo
	Join(table schema.Tabler, on ...field.Expr) IGroupCustomerDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGroupCustomerDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGroupCustomerDo
	Group(cols ...field.Expr) IGroupCustomerDo
	Having(conds ...gen.Condition) IGroupCustomerDo
	Limit(limit int) IGroupCustomerDo
	Offset(offset int) IGroupCustomerDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGroupCustomerDo
	Unscoped() IGroupCustomerDo
	Create(values ...*model.GroupCustomer) error
	CreateInBatches(values []*model.GroupCustomer, batchSize int) error
	Save(values ...*model.GroupCustomer) error
	First() (*model.GroupCustomer, error)
	Take() (*model.GroupCustomer, error)
	Last() (*model.GroupCustomer, error)
	Find() ([]*model.GroupCustomer, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GroupCustomer, err error)
	FindInBatches(result *[]*model.GroupCustomer, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GroupCustomer) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGroupCustomerDo
	Assign(attrs ...field.AssignExpr) IGroupCustomerDo
	Joins(fields ...field.RelationField) IGroupCustomerDo
	Preload(fields ...field.RelationField) IGroupCustomerDo
	FirstOrInit() (*model.GroupCustomer, error)
	FirstOrCreate() (*model.GroupCustomer, error)
	FindByPage(offset int, limit int) (result []*model.GroupCustomer, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGroupCustomerDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g groupCustomerDo) Debug() IGroupCustomerDo {
	return g.withDO(g.DO.Debug())
}

func (g groupCustomerDo) WithContext(ctx context.Context) IGroupCustomerDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g groupCustomerDo) ReadDB() IGroupCustomerDo {
	return g.Clauses(dbresolver.Read)
}

func (g groupCustomerDo) WriteDB() IGroupCustomerDo {
	return g.Clauses(dbresolver.Write)
}

func (g groupCustomerDo) Session(config *gorm.Session) IGroupCustomerDo {
	return g.withDO(g.DO.Session(config))
}

func (g groupCustomerDo) Clauses(conds ...clause.Expression) IGroupCustomerDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g groupCustomerDo) Returning(value interface{}, columns ...string) IGroupCustomerDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g groupCustomerDo) Not(conds ...gen.Condition) IGroupCustomerDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g groupCustomerDo) Or(conds ...gen.Condition) IGroupCustomerDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g groupCustomerDo) Select(conds ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g groupCustomerDo) Where(conds ...gen.Condition) IGroupCustomerDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g groupCustomerDo) Order(conds ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g groupCustomerDo) Distinct(cols ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g groupCustomerDo) Omit(cols ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g groupCustomerDo) Join(table schema.Tabler, on ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g groupCustomerDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g groupCustomerDo) RightJoin(table schema.Tabler, on ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g groupCustomerDo) Group(cols ...field.Expr) IGroupCustomerDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g groupCustomerDo) Having(conds ...gen.Condition) IGroupCustomerDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g groupCustomerDo) Limit(limit int) IGroupCustomerDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g groupCustomerDo) Offset(offset int) IGroupCustomerDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g groupCustomerDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGroupCustomerDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g groupCustomerDo) Unscoped() IGroupCustomerDo {
	return g.withDO(g.DO.Unscoped())
}

func (g groupCustomerDo) Create(values ...*model.GroupCustomer) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g groupCustomerDo) CreateInBatches(values []*model.GroupCustomer, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g groupCustomerDo) Save(values ...*model.GroupCustomer) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g groupCustomerDo) First() (*model.GroupCustomer, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GroupCustomer), nil
	}
}

func (g groupCustomerDo) Take() (*model.GroupCustomer, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GroupCustomer), nil
	}
}

func (g groupCustomerDo) Last() (*model.GroupCustomer, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GroupCustomer), nil
	}
}

func (g groupCustomerDo) Find() ([]*model.GroupCustomer, error) {
	result, err := g.DO.Find()
	return result.([]*model.GroupCustomer), err
}

func (g groupCustomerDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GroupCustomer, err error) {
	buf := make([]*model.GroupCustomer, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g groupCustomerDo) FindInBatches(result *[]*model.GroupCustomer, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g groupCustomerDo) Attrs(attrs ...field.AssignExpr) IGroupCustomerDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g groupCustomerDo) Assign(attrs ...field.AssignExpr) IGroupCustomerDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g groupCustomerDo) Joins(fields ...field.RelationField) IGroupCustomerDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g groupCustomerDo) Preload(fields ...field.RelationField) IGroupCustomerDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g groupCustomerDo) FirstOrInit() (*model.GroupCustomer, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GroupCustomer), nil
	}
}

func (g groupCustomerDo) FirstOrCreate() (*model.GroupCustomer, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GroupCustomer), nil
	}
}

func (g groupCustomerDo) FindByPage(offset int, limit int) (result []*model.GroupCustomer, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g groupCustomerDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g groupCustomerDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g groupCustomerDo) Delete(models ...*model.GroupCustomer) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *groupCustomerDo) withDO(do gen.Dao) *groupCustomerDo {
	g.DO = *do.(*gen.DO)
	return g
}
