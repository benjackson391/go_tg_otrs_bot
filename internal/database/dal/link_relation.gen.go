// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"tg_bot/internal/database/model"
)

func newLinkRelation(db *gorm.DB, opts ...gen.DOOption) linkRelation {
	_linkRelation := linkRelation{}

	_linkRelation.linkRelationDo.UseDB(db, opts...)
	_linkRelation.linkRelationDo.UseModel(&model.LinkRelation{})

	tableName := _linkRelation.linkRelationDo.TableName()
	_linkRelation.ALL = field.NewAsterisk(tableName)
	_linkRelation.SourceObjectID = field.NewInt32(tableName, "source_object_id")
	_linkRelation.SourceKey = field.NewString(tableName, "source_key")
	_linkRelation.TargetObjectID = field.NewInt32(tableName, "target_object_id")
	_linkRelation.TargetKey = field.NewString(tableName, "target_key")
	_linkRelation.TypeID = field.NewInt32(tableName, "type_id")
	_linkRelation.StateID = field.NewInt32(tableName, "state_id")
	_linkRelation.CreateTime = field.NewTime(tableName, "create_time")
	_linkRelation.CreateBy = field.NewInt32(tableName, "create_by")

	_linkRelation.fillFieldMap()

	return _linkRelation
}

type linkRelation struct {
	linkRelationDo

	ALL            field.Asterisk
	SourceObjectID field.Int32
	SourceKey      field.String
	TargetObjectID field.Int32
	TargetKey      field.String
	TypeID         field.Int32
	StateID        field.Int32
	CreateTime     field.Time
	CreateBy       field.Int32

	fieldMap map[string]field.Expr
}

func (l linkRelation) Table(newTableName string) *linkRelation {
	l.linkRelationDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l linkRelation) As(alias string) *linkRelation {
	l.linkRelationDo.DO = *(l.linkRelationDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *linkRelation) updateTableName(table string) *linkRelation {
	l.ALL = field.NewAsterisk(table)
	l.SourceObjectID = field.NewInt32(table, "source_object_id")
	l.SourceKey = field.NewString(table, "source_key")
	l.TargetObjectID = field.NewInt32(table, "target_object_id")
	l.TargetKey = field.NewString(table, "target_key")
	l.TypeID = field.NewInt32(table, "type_id")
	l.StateID = field.NewInt32(table, "state_id")
	l.CreateTime = field.NewTime(table, "create_time")
	l.CreateBy = field.NewInt32(table, "create_by")

	l.fillFieldMap()

	return l
}

func (l *linkRelation) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *linkRelation) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 8)
	l.fieldMap["source_object_id"] = l.SourceObjectID
	l.fieldMap["source_key"] = l.SourceKey
	l.fieldMap["target_object_id"] = l.TargetObjectID
	l.fieldMap["target_key"] = l.TargetKey
	l.fieldMap["type_id"] = l.TypeID
	l.fieldMap["state_id"] = l.StateID
	l.fieldMap["create_time"] = l.CreateTime
	l.fieldMap["create_by"] = l.CreateBy
}

func (l linkRelation) clone(db *gorm.DB) linkRelation {
	l.linkRelationDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l linkRelation) replaceDB(db *gorm.DB) linkRelation {
	l.linkRelationDo.ReplaceDB(db)
	return l
}

type linkRelationDo struct{ gen.DO }

type ILinkRelationDo interface {
	gen.SubQuery
	Debug() ILinkRelationDo
	WithContext(ctx context.Context) ILinkRelationDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ILinkRelationDo
	WriteDB() ILinkRelationDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ILinkRelationDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILinkRelationDo
	Not(conds ...gen.Condition) ILinkRelationDo
	Or(conds ...gen.Condition) ILinkRelationDo
	Select(conds ...field.Expr) ILinkRelationDo
	Where(conds ...gen.Condition) ILinkRelationDo
	Order(conds ...field.Expr) ILinkRelationDo
	Distinct(cols ...field.Expr) ILinkRelationDo
	Omit(cols ...field.Expr) ILinkRelationDo
	Join(table schema.Tabler, on ...field.Expr) ILinkRelationDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILinkRelationDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILinkRelationDo
	Group(cols ...field.Expr) ILinkRelationDo
	Having(conds ...gen.Condition) ILinkRelationDo
	Limit(limit int) ILinkRelationDo
	Offset(offset int) ILinkRelationDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILinkRelationDo
	Unscoped() ILinkRelationDo
	Create(values ...*model.LinkRelation) error
	CreateInBatches(values []*model.LinkRelation, batchSize int) error
	Save(values ...*model.LinkRelation) error
	First() (*model.LinkRelation, error)
	Take() (*model.LinkRelation, error)
	Last() (*model.LinkRelation, error)
	Find() ([]*model.LinkRelation, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LinkRelation, err error)
	FindInBatches(result *[]*model.LinkRelation, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.LinkRelation) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILinkRelationDo
	Assign(attrs ...field.AssignExpr) ILinkRelationDo
	Joins(fields ...field.RelationField) ILinkRelationDo
	Preload(fields ...field.RelationField) ILinkRelationDo
	FirstOrInit() (*model.LinkRelation, error)
	FirstOrCreate() (*model.LinkRelation, error)
	FindByPage(offset int, limit int) (result []*model.LinkRelation, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILinkRelationDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l linkRelationDo) Debug() ILinkRelationDo {
	return l.withDO(l.DO.Debug())
}

func (l linkRelationDo) WithContext(ctx context.Context) ILinkRelationDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l linkRelationDo) ReadDB() ILinkRelationDo {
	return l.Clauses(dbresolver.Read)
}

func (l linkRelationDo) WriteDB() ILinkRelationDo {
	return l.Clauses(dbresolver.Write)
}

func (l linkRelationDo) Session(config *gorm.Session) ILinkRelationDo {
	return l.withDO(l.DO.Session(config))
}

func (l linkRelationDo) Clauses(conds ...clause.Expression) ILinkRelationDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l linkRelationDo) Returning(value interface{}, columns ...string) ILinkRelationDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l linkRelationDo) Not(conds ...gen.Condition) ILinkRelationDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l linkRelationDo) Or(conds ...gen.Condition) ILinkRelationDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l linkRelationDo) Select(conds ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l linkRelationDo) Where(conds ...gen.Condition) ILinkRelationDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l linkRelationDo) Order(conds ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l linkRelationDo) Distinct(cols ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l linkRelationDo) Omit(cols ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l linkRelationDo) Join(table schema.Tabler, on ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l linkRelationDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l linkRelationDo) RightJoin(table schema.Tabler, on ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l linkRelationDo) Group(cols ...field.Expr) ILinkRelationDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l linkRelationDo) Having(conds ...gen.Condition) ILinkRelationDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l linkRelationDo) Limit(limit int) ILinkRelationDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l linkRelationDo) Offset(offset int) ILinkRelationDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l linkRelationDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILinkRelationDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l linkRelationDo) Unscoped() ILinkRelationDo {
	return l.withDO(l.DO.Unscoped())
}

func (l linkRelationDo) Create(values ...*model.LinkRelation) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l linkRelationDo) CreateInBatches(values []*model.LinkRelation, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l linkRelationDo) Save(values ...*model.LinkRelation) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l linkRelationDo) First() (*model.LinkRelation, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.LinkRelation), nil
	}
}

func (l linkRelationDo) Take() (*model.LinkRelation, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.LinkRelation), nil
	}
}

func (l linkRelationDo) Last() (*model.LinkRelation, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.LinkRelation), nil
	}
}

func (l linkRelationDo) Find() ([]*model.LinkRelation, error) {
	result, err := l.DO.Find()
	return result.([]*model.LinkRelation), err
}

func (l linkRelationDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LinkRelation, err error) {
	buf := make([]*model.LinkRelation, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l linkRelationDo) FindInBatches(result *[]*model.LinkRelation, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l linkRelationDo) Attrs(attrs ...field.AssignExpr) ILinkRelationDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l linkRelationDo) Assign(attrs ...field.AssignExpr) ILinkRelationDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l linkRelationDo) Joins(fields ...field.RelationField) ILinkRelationDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l linkRelationDo) Preload(fields ...field.RelationField) ILinkRelationDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l linkRelationDo) FirstOrInit() (*model.LinkRelation, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.LinkRelation), nil
	}
}

func (l linkRelationDo) FirstOrCreate() (*model.LinkRelation, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.LinkRelation), nil
	}
}

func (l linkRelationDo) FindByPage(offset int, limit int) (result []*model.LinkRelation, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l linkRelationDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l linkRelationDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l linkRelationDo) Delete(models ...*model.LinkRelation) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *linkRelationDo) withDO(do gen.Dao) *linkRelationDo {
	l.DO = *do.(*gen.DO)
	return l
}
