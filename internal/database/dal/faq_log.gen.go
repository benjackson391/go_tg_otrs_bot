// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"tg_bot/internal/database/model"
)

func newFaqLog(db *gorm.DB, opts ...gen.DOOption) faqLog {
	_faqLog := faqLog{}

	_faqLog.faqLogDo.UseDB(db, opts...)
	_faqLog.faqLogDo.UseModel(&model.FaqLog{})

	tableName := _faqLog.faqLogDo.TableName()
	_faqLog.ALL = field.NewAsterisk(tableName)
	_faqLog.ID = field.NewInt64(tableName, "id")
	_faqLog.ItemID = field.NewInt32(tableName, "item_id")
	_faqLog.Interface = field.NewString(tableName, "interface")
	_faqLog.IP = field.NewString(tableName, "ip")
	_faqLog.UserAgent = field.NewString(tableName, "user_agent")
	_faqLog.Created = field.NewTime(tableName, "created")

	_faqLog.fillFieldMap()

	return _faqLog
}

type faqLog struct {
	faqLogDo

	ALL       field.Asterisk
	ID        field.Int64
	ItemID    field.Int32
	Interface field.String
	IP        field.String
	UserAgent field.String
	Created   field.Time

	fieldMap map[string]field.Expr
}

func (f faqLog) Table(newTableName string) *faqLog {
	f.faqLogDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f faqLog) As(alias string) *faqLog {
	f.faqLogDo.DO = *(f.faqLogDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *faqLog) updateTableName(table string) *faqLog {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewInt64(table, "id")
	f.ItemID = field.NewInt32(table, "item_id")
	f.Interface = field.NewString(table, "interface")
	f.IP = field.NewString(table, "ip")
	f.UserAgent = field.NewString(table, "user_agent")
	f.Created = field.NewTime(table, "created")

	f.fillFieldMap()

	return f
}

func (f *faqLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *faqLog) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 6)
	f.fieldMap["id"] = f.ID
	f.fieldMap["item_id"] = f.ItemID
	f.fieldMap["interface"] = f.Interface
	f.fieldMap["ip"] = f.IP
	f.fieldMap["user_agent"] = f.UserAgent
	f.fieldMap["created"] = f.Created
}

func (f faqLog) clone(db *gorm.DB) faqLog {
	f.faqLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f faqLog) replaceDB(db *gorm.DB) faqLog {
	f.faqLogDo.ReplaceDB(db)
	return f
}

type faqLogDo struct{ gen.DO }

type IFaqLogDo interface {
	gen.SubQuery
	Debug() IFaqLogDo
	WithContext(ctx context.Context) IFaqLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFaqLogDo
	WriteDB() IFaqLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFaqLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFaqLogDo
	Not(conds ...gen.Condition) IFaqLogDo
	Or(conds ...gen.Condition) IFaqLogDo
	Select(conds ...field.Expr) IFaqLogDo
	Where(conds ...gen.Condition) IFaqLogDo
	Order(conds ...field.Expr) IFaqLogDo
	Distinct(cols ...field.Expr) IFaqLogDo
	Omit(cols ...field.Expr) IFaqLogDo
	Join(table schema.Tabler, on ...field.Expr) IFaqLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFaqLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFaqLogDo
	Group(cols ...field.Expr) IFaqLogDo
	Having(conds ...gen.Condition) IFaqLogDo
	Limit(limit int) IFaqLogDo
	Offset(offset int) IFaqLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFaqLogDo
	Unscoped() IFaqLogDo
	Create(values ...*model.FaqLog) error
	CreateInBatches(values []*model.FaqLog, batchSize int) error
	Save(values ...*model.FaqLog) error
	First() (*model.FaqLog, error)
	Take() (*model.FaqLog, error)
	Last() (*model.FaqLog, error)
	Find() ([]*model.FaqLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FaqLog, err error)
	FindInBatches(result *[]*model.FaqLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FaqLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFaqLogDo
	Assign(attrs ...field.AssignExpr) IFaqLogDo
	Joins(fields ...field.RelationField) IFaqLogDo
	Preload(fields ...field.RelationField) IFaqLogDo
	FirstOrInit() (*model.FaqLog, error)
	FirstOrCreate() (*model.FaqLog, error)
	FindByPage(offset int, limit int) (result []*model.FaqLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFaqLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f faqLogDo) Debug() IFaqLogDo {
	return f.withDO(f.DO.Debug())
}

func (f faqLogDo) WithContext(ctx context.Context) IFaqLogDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f faqLogDo) ReadDB() IFaqLogDo {
	return f.Clauses(dbresolver.Read)
}

func (f faqLogDo) WriteDB() IFaqLogDo {
	return f.Clauses(dbresolver.Write)
}

func (f faqLogDo) Session(config *gorm.Session) IFaqLogDo {
	return f.withDO(f.DO.Session(config))
}

func (f faqLogDo) Clauses(conds ...clause.Expression) IFaqLogDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f faqLogDo) Returning(value interface{}, columns ...string) IFaqLogDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f faqLogDo) Not(conds ...gen.Condition) IFaqLogDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f faqLogDo) Or(conds ...gen.Condition) IFaqLogDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f faqLogDo) Select(conds ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f faqLogDo) Where(conds ...gen.Condition) IFaqLogDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f faqLogDo) Order(conds ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f faqLogDo) Distinct(cols ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f faqLogDo) Omit(cols ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f faqLogDo) Join(table schema.Tabler, on ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f faqLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f faqLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f faqLogDo) Group(cols ...field.Expr) IFaqLogDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f faqLogDo) Having(conds ...gen.Condition) IFaqLogDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f faqLogDo) Limit(limit int) IFaqLogDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f faqLogDo) Offset(offset int) IFaqLogDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f faqLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFaqLogDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f faqLogDo) Unscoped() IFaqLogDo {
	return f.withDO(f.DO.Unscoped())
}

func (f faqLogDo) Create(values ...*model.FaqLog) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f faqLogDo) CreateInBatches(values []*model.FaqLog, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f faqLogDo) Save(values ...*model.FaqLog) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f faqLogDo) First() (*model.FaqLog, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqLog), nil
	}
}

func (f faqLogDo) Take() (*model.FaqLog, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqLog), nil
	}
}

func (f faqLogDo) Last() (*model.FaqLog, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqLog), nil
	}
}

func (f faqLogDo) Find() ([]*model.FaqLog, error) {
	result, err := f.DO.Find()
	return result.([]*model.FaqLog), err
}

func (f faqLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FaqLog, err error) {
	buf := make([]*model.FaqLog, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f faqLogDo) FindInBatches(result *[]*model.FaqLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f faqLogDo) Attrs(attrs ...field.AssignExpr) IFaqLogDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f faqLogDo) Assign(attrs ...field.AssignExpr) IFaqLogDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f faqLogDo) Joins(fields ...field.RelationField) IFaqLogDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f faqLogDo) Preload(fields ...field.RelationField) IFaqLogDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f faqLogDo) FirstOrInit() (*model.FaqLog, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqLog), nil
	}
}

func (f faqLogDo) FirstOrCreate() (*model.FaqLog, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FaqLog), nil
	}
}

func (f faqLogDo) FindByPage(offset int, limit int) (result []*model.FaqLog, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f faqLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f faqLogDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f faqLogDo) Delete(models ...*model.FaqLog) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *faqLogDo) withDO(do gen.Dao) *faqLogDo {
	f.DO = *do.(*gen.DO)
	return f
}
